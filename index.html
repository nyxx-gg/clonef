<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jokes On You â€” Screenshot Gallery</title>

<!-- Google Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Mansalva&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

<style>
  :root {
    --bg: #ffffff;
    --card: #797979;
    --muted: #6b7280;
    --gap: 1rem;
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    font-family: Inter, sans-serif;
    background: var(--bg);
    color: #272727;
  }

  header {
    padding: 2rem 1rem 1rem;
    text-align: center;
  }
  h1 {
    font-family: 'Mansalva', cursive;
    font-size: 77px;
    margin: 0;
    color: #000;
    line-height: 1;
    text-align: center;
    will-change: transform, font-size;
  }

  .gallery-wrap {
    padding: 1rem;
    width: 100%;
    max-width: 1400px;
    margin: auto;
  }

  /* Masonry using CSS columns */
  .gallery {
    column-gap: var(--gap);
    width: 100%;
    column-fill: balance;
  }
  @media (min-width:1400px){ .gallery{column-count:4;} }
  @media (min-width:1000px) and (max-width:1399px){ .gallery{column-count:3;} }
  @media (min-width:700px) and (max-width:999px){ .gallery{column-count:2;} }
  @media (max-width:699px){ .gallery{column-count:1;} }

  .item {
    display: inline-block;
    width: 100%;
    margin: 0 0 var(--gap);
    break-inside: avoid;
    /* make card background invisible while keeping rounded image corners */
    background: transparent;
    padding: 0;
    border-radius: 0;
    box-shadow: none;
  }
  .item img {
    width: 100%;
    border-radius: 12px; /* keep rounded corners on the image */
    display: block;
  }
  .item p {
    margin: .5rem 0 0;
    color: #000; /* caption text back-coloured (black) */
    font-size: .9rem;
    word-break: break-word;
  }

  .upload-box {
    background: #fff;
    color: #000;
    padding: 1rem 1.2rem;
    width: min(500px, 90%);
    border-radius: 18px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.3);
    display: flex;
    flex-direction: column;
    gap: .75rem;
  }

  .upload-box.dragover {
    outline: 3px dashed rgba(15,23,36,0.6);
    background: #fbfbfb;
  }

  /* small screens - tighter title size */
  @media (max-width:420px){
    h1{ font-size: 2.3rem; }
  }

  /* Search sidebar */
  .search-toggle {
    background: #0f1724;
    color: #fff;
    border-radius: 999px;
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 6px 18px rgba(0,0,0,0.2);
    cursor: pointer;
    z-index: 1100;
  }

  .search-panel {
    position: fixed;
    left: 0;
    top: 0;
    bottom: 0;
    width: 320px;
    background: #ffffff;
    box-shadow: 4px 0 24px rgba(0,0,0,0.12);
    transform: translateX(-100%);
    transition: transform 220ms ease;
    z-index: 1090;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: .75rem;
  }

  .search-panel.open { transform: translateX(0); }

  .search-panel input[type="search"] {
    width: 100%;
    padding: .6rem .8rem;
    border-radius: 8px;
    border: 1px solid #ddd;
    font-size: 1rem;
  }

  .search-panel .close-btn {
    background: transparent;
    border: none;
    color: #333;
    font-size: 1.1rem;
    cursor: pointer;
    align-self: flex-end;
  }

  .search-results {
    overflow: auto;
    flex: 1 1 auto;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: .6rem;
    align-items: start;
  }

  .search-result {
    display: flex;
    flex-direction: column;
    gap: .45rem;
    align-items: stretch;
    padding: .5rem;
    border-radius: 8px;
    border: 1px solid #f5f5f5;
    background: #fff;
    cursor: pointer;
  }

  .search-result img { width: 100%; height: 120px; object-fit: cover; border-radius: 8px; display: block; }
  .search-result .meta { font-size: .9rem; color: #333; line-height: 1.2; padding: 0 .15rem .25rem; text-align: left; }
  /* Left tools and add-panel styles */
  .left-tools { position: fixed; left: 12px; top: 50%; transform: translateY(-50%); display:flex; flex-direction:column; gap:.6rem; z-index:1110; }
  .add-toggle { background: #0f1724; color: #fff; border-radius: 999px; width:48px; height:48px; display:flex; align-items:center; justify-content:center; box-shadow:0 6px 18px rgba(0,0,0,0.2); cursor:pointer; border: none; }
  .add-panel { position: fixed; left: 0; top: 0; bottom: 0; width: 360px; background: #ffffff; box-shadow: 4px 0 24px rgba(0,0,0,0.12); transform: translateX(-100%); transition: transform 220ms ease; z-index: 1105; padding: 1rem; display: flex; flex-direction: column; gap: .75rem; }
  .add-panel.open { transform: translateX(0); }
  .add-panel.dragover { outline: 3px dashed rgba(15,23,36,0.6); background: #fbfbfb; }
  /* Lightbox / post view */
  .lightbox {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.6);
    z-index: 1200;
    padding: 2rem;
  }
  .lightbox.open { display: flex; }
  .lightbox-content {
    background: #fff;
    border-radius: 12px;
    max-width: 1100px;
    width: 100%;
    max-height: 90vh;
    overflow: auto;
    position: relative;
    box-shadow: 0 20px 60px rgba(0,0,0,0.4);
  }
  .lightbox-content img {
    display: block;
    width: 100%;
    height: auto;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    object-fit: contain;
    background: #000;
  }
  .lightbox-caption {
    padding: 1rem;
    color: #222;
    font-size: 1rem;
  }
  .close-lightbox {
    position: absolute;
    right: 8px;
    top: 8px;
    background: rgba(15,23,36,0.95);
    color: #fff;
    border: none;
    width: 36px;
    height: 36px;
    border-radius: 999px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 1210;
  }
  /* Profile modal (post-sized view) */
  .profile-modal {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.6);
    z-index: 1250;
    padding: 2rem;
  }
  .profile-modal.open { display: flex; }
  .profile-content {
    background: #fff;
    border-radius: 12px;
    width: 100%;
    max-width: 900px;
    max-height: 85vh;
    position: relative;
    padding: 1.25rem 1.5rem 2rem;
    box-shadow: 0 30px 80px rgba(0,0,0,0.45);
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  .profile-close {
    position: absolute;
    right: 12px;
    top: 12px;
    background: transparent;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    color: #666;
  }
  .profile-top { display: flex; flex-direction: column; align-items: center; gap: .5rem; padding-top: .6rem; flex: 0 0 auto; }
  .profile-avatar { width: 96px; height: 96px; border-radius: 999px; background: #f0f0f0; display:flex; align-items:center; justify-content:center; overflow: hidden; cursor: pointer; border: 4px solid #fff; box-shadow: 0 6px 20px rgba(0,0,0,0.08); }
  .profile-avatar img { width: 100%; height: 100%; object-fit: cover; display: block; }
  .profile-username { font-family: 'Mansalva', cursive; font-size: 28px; margin-top: .35rem; color: #000; }

  .profile-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1rem; flex: 1 1 auto; overflow: auto; padding-bottom: 0.5rem; }
  @media (max-width:800px) { .profile-grid { grid-template-columns: repeat(2, 1fr); } }
  @media (max-width:420px) { .profile-grid { grid-template-columns: 1fr; } }
  .profile-item { display: flex; flex-direction: column; gap: .4rem; align-items: center; }
  .profile-item img { width: 100%; height: 120px; object-fit: cover; border-radius: 12px; display: block; }
  .profile-item .cap { font-size: .95rem; color: #222; text-align: center; margin-top: .25rem; }

  /* hidden file input for avatar upload */
  #profilePicInput { display: none; }
  /* Crop modal */
  .crop-modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.6); z-index: 1300; padding: 2rem; }
  .crop-modal.open { display: flex; }
  .crop-card { background: #fff; border-radius: 12px; padding: 1rem; width: 100%; max-width: 520px; box-shadow: 0 30px 80px rgba(0,0,0,0.4); display:flex; flex-direction:column; gap:.75rem; }
  .crop-viewport { width: 360px; height: 360px; max-width: calc(100% - 40px); background: #111; margin: 0 auto; overflow: hidden; position: relative; border-radius: 8px; }
  .crop-viewport img { position: absolute; top:0; left:0; user-select: none; touch-action: none; cursor: grab; }
  .crop-controls { display:flex; gap:.5rem; align-items:center; justify-content:center; }
  .crop-controls input[type=range] { width: 60%; }
  .crop-actions { display:flex; gap:.5rem; justify-content:flex-end; }
  /* Welcome toast */
  .welcome-toast {
    font-family: 'Mansalva', cursive;
    position: fixed;
    left: 50%;
    bottom: 24px;
    transform: translateX(-50%) translateY(100%);
    background: rgba(15,23,36,0.95);
    color: #fff;
    padding: 10px 18px;
    border-radius: 999px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.35);
    font-size: 20px;
    z-index: 2000;
    opacity: 0;
  }
  @keyframes slideWelcome {
    0% { transform: translateX(-50%) translateY(100%); opacity: 0; }
    15% { transform: translateX(-50%) translateY(0%); opacity: 1; }
    85% { transform: translateX(-50%) translateY(0%); opacity: 1; }
    100% { transform: translateX(-50%) translateY(100%); opacity: 0; }
  }
  .welcome-toast.animate { animation: slideWelcome 1s ease forwards; }
  /* utility hidden class */
  .hidden { display: none !important; }

  /* Fullscreen auth landing (login/register) */
  .auth-screen {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #ffffff;
    z-index: 1600;
    padding: 2rem;
  }
  .auth-screen.hidden { display: none; }
  .auth-card {
    width: 100%;
    max-width: 480px;
    border-radius: 12px;
    padding: 2rem;
    box-shadow: 0 20px 60px rgba(0,0,0,0.12);
    background: #fff;
  }
  .auth-tabs { display:flex; gap: .5rem; margin-bottom: 1rem; }
  .auth-tabs button { flex:1; padding: .6rem; border-radius: 8px; border:1px solid #eee; background:#fafafa; cursor:pointer; }
  .auth-tabs button.active { background: #0f1724; color:#fff; border-color: rgba(0,0,0,0.06); }
  .auth-form .form-row { margin-bottom: .9rem; }
  .auth-form label { display:block; font-size:.9rem; margin-bottom:.25rem; color:#333; }
  .auth-form input { width:100%; padding:.65rem .8rem; border-radius:8px; border:1px solid #ddd; }
  .auth-form .error { color:#d32f2f; font-size:.85rem; margin-top:.35rem; }
  .auth-actions { margin-top: .6rem; }
</style>
</head>
<body>
  <script>
 

  // Title shrink/translate behavior on scroll
  const title = document.querySelector('header h1');
  const TITLE_MAX = 77; // px
  const TITLE_MIN = 45; // px
  const SCROLL_THRESHOLD = 200; // px of scroll when title reaches min size

  function applyTitleTransform(scrollY) {
    if (!title) return;
    const progress = Math.min(Math.max(scrollY / SCROLL_THRESHOLD, 0), 1);
    const size = TITLE_MAX - (TITLE_MAX - TITLE_MIN) * progress;
    const translateY = -30 * progress; // move up by up to 30px
    title.style.fontSize = size + 'px';
    title.style.transform = `translateY(${translateY}px)`;
  }

  let ticking = false;
  window.addEventListener('scroll', () => {
    if (!ticking) {
      window.requestAnimationFrame(() => {
        applyTitleTransform(window.scrollY || window.pageYOffset);
        ticking = false;
      });
      ticking = true;
    }
  });

  // initialize on load
  applyTitleTransform(window.scrollY || window.pageYOffset);

  // Add panel wiring
  const addToggle = document.getElementById('addToggle');
  const addPanel = document.getElementById('addPanel');
  const addClose = document.getElementById('addClose');
  const addFileInput = document.getElementById('addFileInput');
  const addDescInput = document.getElementById('addDescInput');
  const addUploadBtn = document.getElementById('addUploadBtn');

  function openAdd() {
    // close search if open
    if (searchPanel && searchPanel.classList.contains('open')) closeSearch();
    addPanel.classList.add('open');
    addPanel.setAttribute('aria-hidden', 'false');
    setTimeout(() => addFileInput.focus(), 200);
  }
  function closeAdd() {
    addPanel.classList.remove('open');
    addPanel.setAttribute('aria-hidden', 'true');
    // reset fields
    addFileInput.value = '';
    addDescInput.value = '';
  }

  if (addToggle) addToggle.addEventListener('click', () => { if (addPanel.classList.contains('open')) closeAdd(); else openAdd(); });
  if (addClose) addClose.addEventListener('click', closeAdd);

  if (addUploadBtn) addUploadBtn.addEventListener('click', () => {
    const f = addFileInput.files && addFileInput.files[0];
    const desc = addDescInput.value.trim();
    if (!f) { alert('Please choose an image to upload.'); return; }
    processFile(f, desc);
    closeAdd();
  });

  // allow Enter in addDescInput to submit
  if (addDescInput) addDescInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      addUploadBtn.click();
    }
  });

  // Lightbox: open when clicking a gallery image
  const lightbox = document.getElementById('lightbox');
  const lightboxImg = document.getElementById('lightboxImg');
  const lightboxCaption = document.getElementById('lightboxCaption');
  const closeLightboxBtn = document.getElementById('closeLightbox');

  function openLightbox(src, caption, alt) {
    if (!lightbox) return;
    lightboxImg.src = src || '';
    lightboxImg.alt = alt || '';
    lightboxCaption.textContent = caption || '';
    lightbox.classList.add('open');
    lightbox.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
    closeLightboxBtn.focus();
  }

  function closeLightbox() {
    if (!lightbox) return;
    lightbox.classList.remove('open');
    lightbox.setAttribute('aria-hidden', 'true');
    lightboxImg.src = '';
    lightboxCaption.textContent = '';
    document.body.style.overflow = '';
  }

  // expose lightbox controls to the global scope so other code (e.g. search) can open/close it
  window.openLightbox = openLightbox;
  window.closeLightbox = closeLightbox;

  // Delegated click handler on gallery
  const galleryEl = document.getElementById('gallery');
  if (galleryEl) {
    galleryEl.addEventListener('click', (e) => {
      const img = e.target.closest('img');
      if (!img) return;
      const item = img.closest('.item');
      const descEl = item ? item.querySelector('p') : null;
      const caption = descEl ? descEl.textContent : '';
      openLightbox(img.src, caption, img.alt || 'image');
    });
  }

  // close handlers
  if (closeLightboxBtn) closeLightboxBtn.addEventListener('click', closeLightbox);
  if (lightbox) lightbox.addEventListener('click', (e) => { if (e.target === lightbox) closeLightbox(); });
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeLightbox(); });

;

/* Search logic: filters gallery and populates the side results */
function performSearch(query) {
  const gallery = document.getElementById('gallery');
  const resultsContainer = document.getElementById('searchResults');
  const countEl = document.getElementById('searchCount');
  if (!gallery || !resultsContainer) return;

  const q = (query || '').toLowerCase();
  resultsContainer.innerHTML = '';
  let matchCount = 0;

  Array.from(gallery.children).forEach(item => {
    const desc = item.dataset.desc || '';
    const fname = item.dataset.filename || '';
    const isMatch = q === '' || desc.includes(q) || fname.includes(q);
    item.style.display = isMatch ? 'inline-block' : 'none';
    if (isMatch && q !== '') {
      // add to side results: small thumbnail + text
      const thumb = document.createElement('div');
      thumb.className = 'search-result';
      const img = item.querySelector('img');
      const clone = document.createElement('img');
      clone.src = img ? img.src : '';
      clone.alt = img ? img.alt : '';
      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = (item.querySelector('p') ? item.querySelector('p').textContent : fname) || fname || 'file';
      thumb.appendChild(clone);
      thumb.appendChild(meta);
      thumb.addEventListener('click', () => {
        // Open the matched post in the same lightbox used on the homepage
        const imgEl = item.querySelector('img');
        const descEl = item.querySelector('p');
        const caption = descEl ? descEl.textContent : '';
        if (imgEl && window.openLightbox) {
          window.openLightbox(imgEl.src, caption, imgEl.alt || 'image');
        } else if (imgEl) {
          // fallback: scroll into view
          item.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // close search panel after opening
        const sp = document.getElementById('searchPanel');
        if (sp && sp.classList.contains('open')) {
          sp.classList.remove('open');
          sp.setAttribute('aria-hidden', 'true');
          const searchInput = document.getElementById('searchInput');
          if (searchInput) searchInput.value = '';
        }
      });
      resultsContainer.appendChild(thumb);
      matchCount++;
    }
  });

  // update count
  if (countEl) countEl.textContent = q === '' ? '' : `${matchCount} result${matchCount === 1 ? '' : 's'}`;
}

/* ========== Profile view (frontend only hooks) ========== */

// Open profile modal
function openProfile() {
  const pm = document.getElementById('profileModal');
  if (!pm) return;
  // populate username and avatar from Firebase Auth
  const nameEl = document.getElementById('profileName');
  const avatarImg = document.getElementById('profileAvatarImg');
  const user = window.firebaseAuthUser || null;
  let username = user && user.displayName ? user.displayName : 'Username';
  nameEl.textContent = username;
  // TODO: Load profile picture from Firestore or Cloudinary
  avatarImg.src = user && user.photoURL ? user.photoURL : (window.__DEFAULT_PROFILE_AVATAR || avatarImg.src);

  // build profile grid: show items that belong to the user (dataset.owner)
  const grid = document.getElementById('profileGrid');
  grid.innerHTML = '';
  const gallery = document.getElementById('gallery');
  if (gallery && user) {
    const items = Array.from(gallery.children);
    // show items with matching ownerId
    const owned = items.filter(it => (it.dataset.owner || '') === user.uid);
    const toShow = owned.length ? owned : items;
    toShow.forEach(it => {
      const img = it.querySelector('img');
      const cap = it.querySelector('p');
      const tile = document.createElement('div');
      tile.className = 'profile-item';
      const thumb = document.createElement('img');
      thumb.src = img ? img.src : '';
      thumb.alt = img ? img.alt : 'post';
      thumb.addEventListener('click', () => {
        if (window.openLightbox) window.openLightbox(thumb.src, cap ? cap.textContent : '', thumb.alt || 'image');
        closeProfile();
      });
      const caption = document.createElement('div');
      caption.className = 'cap';
      caption.textContent = cap ? cap.textContent : '';
      tile.appendChild(thumb);
      tile.appendChild(caption);
      grid.appendChild(tile);
    });
  }
}
// ...existing code...
// Track Firebase user globally for gallery/profile logic
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
const auth1 = getAuth();
window.firebaseAuthUser = null;
onAuthStateChanged(auth1, (user) => {
  window.firebaseAuthUser = user;
});

  pm.classList.add('open');
  pm.setAttribute('aria-hidden', 'false');
  document.body.style.overflow = 'hidden';

function closeProfile() {
  const pm = document.getElementById('profileModal');
  if (!pm) return;
  pm.classList.remove('open');
  pm.setAttribute('aria-hidden', 'true');
  document.body.style.overflow = '';
}

// handle clicking avatar to upload a new profile picture (frontend-only)
document.addEventListener('DOMContentLoaded', () => {
  const profileToggle = document.getElementById('profileToggle');
  if (profileToggle) profileToggle.addEventListener('click', openProfile);

  const profileAvatar = document.getElementById('profileAvatar');
  const profilePicInput = document.getElementById('profilePicInput');
  const closeProfileBtn = document.getElementById('closeProfile');

  if (profileAvatar && profilePicInput) {
    profileAvatar.addEventListener('click', () => profilePicInput.click());
    profilePicInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        const src = ev.target.result;
        // open crop modal
        const cropModal = document.getElementById('cropModal');
        const cropImg = document.getElementById('cropImage');
        const zoom = document.getElementById('cropZoom');
        if (!cropModal || !cropImg || !zoom) return;
        cropImg.src = src;
        // reset transforms
        cropImg.style.transform = '';
        cropImg.style.left = '0px';
        cropImg.style.top = '0px';
        zoom.value = 1;
        cropModal.classList.add('open');
        cropModal.setAttribute('aria-hidden', 'false');
        // prepare dragging/zoom logic
        setupCropInteractions();
      };
      reader.readAsDataURL(f);
    });
  }

  if (closeProfileBtn) closeProfileBtn.addEventListener('click', closeProfile);
  // close when clicking the overlay
  const pm = document.getElementById('profileModal');
  if (pm) pm.addEventListener('click', (e) => { if (e.target === pm) closeProfile(); });
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeProfile(); });
});

// Crop modal interactions (drag image and zoom then crop)
function setupCropInteractions() {
  const cropModal = document.getElementById('cropModal');
  const cropViewport = document.getElementById('cropViewport');
  const cropImg = document.getElementById('cropImage');
  const zoomInput = document.getElementById('cropZoom');
  const cancelBtn = document.getElementById('cropCancel');
  const doneBtn = document.getElementById('cropDone');
  if (!cropModal || !cropViewport || !cropImg || !zoomInput) return;

  // state
  let isPointerDown = false;
  let startX = 0, startY = 0;
  let imgLeft = 0, imgTop = 0;
  let baseScale = 1; // initial fit scale
  let scale = 1;

  function resetPosition() {
    // compute natural size and fit center
    const naturalW = cropImg.naturalWidth || cropImg.width;
    const naturalH = cropImg.naturalHeight || cropImg.height;
    const vw = cropViewport.clientWidth;
    const vh = cropViewport.clientHeight;
    // fit to cover: ensure image covers viewport
    const fitScale = Math.max(vw / naturalW, vh / naturalH);
    baseScale = fitScale;
    scale = 1;
    zoomInput.value = 1;
    const displayW = naturalW * baseScale;
    const displayH = naturalH * baseScale;
    imgLeft = (vw - displayW) / 2;
    imgTop = (vh - displayH) / 2;
    applyTransform();
  }

  function applyTransform() {
    const s = baseScale * scale;
    cropImg.style.width = (cropImg.naturalWidth * s) + 'px';
    cropImg.style.height = (cropImg.naturalHeight * s) + 'px';
    cropImg.style.left = imgLeft + 'px';
    cropImg.style.top = imgTop + 'px';
  }

  function onPointerDown(e) {
    e.preventDefault();
    isPointerDown = true;
    startX = e.clientX || (e.touches && e.touches[0].clientX);
    startY = e.clientY || (e.touches && e.touches[0].clientY);
    cropImg.style.cursor = 'grabbing';
  }
  function onPointerMove(e) {
    if (!isPointerDown) return;
    const x = e.clientX || (e.touches && e.touches[0].clientX);
    const y = e.clientY || (e.touches && e.touches[0].clientY);
    const dx = x - startX;
    const dy = y - startY;
    startX = x; startY = y;
    imgLeft += dx; imgTop += dy;
    applyTransform();
  }
  function onPointerUp() { isPointerDown = false; cropImg.style.cursor = 'grab'; }

  // zoom change
  zoomInput.oninput = function() {
    const prevScale = scale;
    scale = parseFloat(zoomInput.value) || 1;
    // adjust imgLeft/imgTop so center stays approximately the same
    const vw = cropViewport.clientWidth;
    const vh = cropViewport.clientHeight;
    const cx = vw/2 - imgLeft;
    const cy = vh/2 - imgTop;
    const ratio = (baseScale * scale) / (baseScale * prevScale);
    imgLeft = vw/2 - cx * ratio;
    imgTop = vh/2 - cy * ratio;
    applyTransform();
  };

  // attach events
  cropImg.addEventListener('mousedown', onPointerDown);
  window.addEventListener('mousemove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);
  // touch
  cropImg.addEventListener('touchstart', onPointerDown, {passive:false});
  window.addEventListener('touchmove', onPointerMove, {passive:false});
  window.addEventListener('touchend', onPointerUp);

  // when image loads, reset position
  if (cropImg.complete) resetPosition();
  else cropImg.onload = resetPosition;

  // cancel
  if (cancelBtn) cancelBtn.onclick = function() { cropModal.classList.remove('open'); cropModal.setAttribute('aria-hidden','true'); };

  // done: perform crop and set avatar
      if (doneBtn) doneBtn.onclick = function() {
    try {
      const vw = cropViewport.clientWidth;
      const vh = cropViewport.clientHeight;
      const s = baseScale * scale;
      const naturalW = cropImg.naturalWidth;
      const naturalH = cropImg.naturalHeight;
      // top-left in natural coords
      const nx = Math.max(0, (-imgLeft) / s);
      const ny = Math.max(0, (-imgTop) / s);
      const nw = Math.min(naturalW - nx, vw / s);
      const nh = Math.min(naturalH - ny, vh / s);
      // draw to canvas as square (use vw x vh area)
      const outSize = 200;
      const canvas = document.createElement('canvas');
      canvas.width = outSize; canvas.height = outSize;
      const ctx = canvas.getContext('2d');
      // maintain aspect by drawing the vw/vh region scaled to outSize
      ctx.drawImage(cropImg, nx, ny, nw, nh, 0, 0, outSize, outSize);
      const dataUrl = canvas.toDataURL('image/png');
      const avatar = document.getElementById('profileAvatarImg');
      if (avatar) avatar.src = dataUrl;
      try {
        // store per-user profile pic if logged in; do NOT write the legacy
        // `profile_pic` key for anonymous users (that caused shared avatars).
        const authNow = JSON.parse(sessionStorage.getItem('auth_user') || '{}');
        const usernameNow = authNow && authNow.username ? authNow.username : null;
        if (usernameNow) {
          const key = profileStorageKey(usernameNow);
          localStorage.setItem(key, dataUrl);
        }
      } catch(e){}
    } catch (err) { console.error('Crop failed', err); }
    cropModal.classList.remove('open'); cropModal.setAttribute('aria-hidden','true');
  };
}

// show a brief welcome toast that slides up then down (1s total)
function showWelcomeToast(username) {
  if (!username) return;
  const existing = document.querySelector('.welcome-toast');
  if (existing) existing.remove();
  const el = document.createElement('div');
  el.className = 'welcome-toast';
  el.textContent = `Welcome back, ${username}`;
  document.body.appendChild(el);
  // force reflow then animate
  void el.offsetWidth;
  el.classList.add('animate');
  el.addEventListener('animationend', () => { el.remove(); });
}

/* ========== Landing auth logic (login/register) ========== */
// helper: SHA-256 hash a string and return base64
async function hashPassword(password) {
  const enc = new TextEncoder();
  const data = enc.encode(password);
  const hash = await crypto.subtle.digest('SHA-256', data);
  // convert to base64
  const arr = Array.from(new Uint8Array(hash));
  const bin = arr.map(b => String.fromCharCode(b)).join('');
  return btoa(bin);
}

// demo user store helpers (replace these with backend calls)
function getDemoUsers() {
  try { return JSON.parse(localStorage.getItem('demo_users') || '[]'); } catch (e) { return []; }
}
function saveDemoUsers(list) { try { localStorage.setItem('demo_users', JSON.stringify(list)); } catch(e){} }

// profile storage key helper (per-user)
function profileStorageKey(username) {
  if (!username) return 'profile_pic';
  return 'profile_pic_' + username.toString().toLowerCase();
}

async function registerLanding(username, password, avatarData = null) {
  // placeholder for backend POST /register
  const users = getDemoUsers();
  if (!username || !password) throw new Error('username and password required');
  const exists = users.find(u => u.username.toLowerCase() === username.toLowerCase());
  if (exists) throw new Error('username_taken');
  const pwHash = await hashPassword(password);
  const userObj = { username, pwHash, created: new Date().toISOString() };
  if (avatarData) {
    try {
      userObj.avatarData = avatarData;
      // store per-user key for backwards compatibility
      localStorage.setItem(profileStorageKey(username), avatarData);
    } catch (e) { /* ignore storage errors */ }
  }
  users.push(userObj);
  saveDemoUsers(users);
  // set auth_user for now (session-only so user is logged-out on close)
  const token = 'local_' + Date.now();
  const auth = { username, token };
  try { sessionStorage.setItem('auth_user', JSON.stringify(auth)); } catch(e){}
  return auth;
}

async function loginLanding(username, password) {
  // placeholder for backend POST /login
  const users = getDemoUsers();
  const found = users.find(u => u.username.toLowerCase() === (username||'').toLowerCase());
  if (!found) throw new Error('wrong_credentials');
  const pwHash = await hashPassword(password);
  if (pwHash !== found.pwHash) throw new Error('wrong_credentials');
  const token = 'local_' + Date.now();
  const auth = { username: found.username, token };
  try { sessionStorage.setItem('auth_user', JSON.stringify(auth)); } catch(e){}
  return auth;
}

// wire landing UI
document.addEventListener('DOMContentLoaded', () => {
  const authScreen = document.getElementById('authScreen');
  const tabLogin = document.getElementById('tabLogin');
  const tabRegister = document.getElementById('tabRegister');
  const loginBox = document.getElementById('loginBox');
  const registerBox = document.getElementById('registerBox');

  function showLogin() { tabLogin.classList.add('active'); tabRegister.classList.remove('active'); loginBox.classList.remove('hidden'); registerBox.classList.add('hidden'); }
  function showRegister() { tabLogin.classList.remove('active'); tabRegister.classList.add('active'); loginBox.classList.add('hidden'); registerBox.classList.remove('hidden'); }

  tabLogin.addEventListener('click', showLogin);
  tabRegister.addEventListener('click', showRegister);

  // login handler
  document.getElementById('landingLoginBtn').addEventListener('click', async () => {
    const u = document.getElementById('landingLoginUser').value.trim();
    const p = document.getElementById('landingLoginPass').value;
    document.getElementById('landingLoginMsg').textContent = '';
    try {
      await loginLanding(u, p);
      // load avatar from demo users if present and set into per-user storage & UI
      try {
        const users = getDemoUsers();
        const found = users.find(x => x.username && x.username.toLowerCase() === (u || '').toLowerCase());
        const avatarImg = document.getElementById('profileAvatarImg');
        if (found && found.avatarData) {
          try { localStorage.setItem(profileStorageKey(found.username), found.avatarData); } catch(e){}
          if (avatarImg) avatarImg.src = found.avatarData;
        } else {
          // ensure we do not accidentally show a global legacy avatar for this user
          try { localStorage.removeItem(profileStorageKey(u)); } catch(e){}
          if (avatarImg) avatarImg.src = window.__DEFAULT_PROFILE_AVATAR || avatarImg.src;
        }
      } catch(e) { console.warn('Could not load avatar after login', e); }
      // hide auth screen and update UI
      if (authScreen) authScreen.classList.add('hidden');
      // update profile and header
      try { const stored = JSON.parse(sessionStorage.getItem('auth_user') || '{}'); if (stored && stored.username) { const userInfo = document.getElementById('userInfo'); if (userInfo) { userInfo.textContent = 'Welcome, ' + stored.username; userInfo.classList.remove('hidden'); } const loginHeaderBtn = document.getElementById('loginHeaderBtn'); if (loginHeaderBtn) loginHeaderBtn.classList.add('hidden'); const logoutBtn = document.getElementById('logoutBtn'); if (logoutBtn) logoutBtn.classList.remove('hidden'); if (window.showWelcomeToast) window.showWelcomeToast(stored.username); }} catch(e){}
    } catch (err) {
      console.error('login error', err);
      document.getElementById('landingLoginMsg').textContent = err.message === 'wrong_credentials' ? 'wrong credentials' : (err.message || 'Login failed');
    }
  });

  // register handler
  document.getElementById('landingRegBtn').addEventListener('click', async () => {
    const u = document.getElementById('landingRegUser').value.trim();
    const p = document.getElementById('landingRegPass').value;
    const p2 = document.getElementById('landingRegPass2').value;
    document.getElementById('landingRegMsg').textContent = '';
    if (!u) { document.getElementById('landingRegUserErr').textContent = 'Enter a username'; return; } else { document.getElementById('landingRegUserErr').textContent = ''; }
    if (!p || p.length < 6) { document.getElementById('landingRegPassErr').textContent = 'Password must be 6+ chars'; return; } else { document.getElementById('landingRegPassErr').textContent = ''; }
    if (p !== p2) { document.getElementById('landingRegPass2Err').textContent = 'Passwords do not match'; return; } else { document.getElementById('landingRegPass2Err').textContent = ''; }
    try {
      // check for optional profile picture and read as dataURL if present
      let avatarData = null;
      try {
        const picInput = document.getElementById('landingRegPic');
        if (picInput && picInput.files && picInput.files[0]) {
          const file = picInput.files[0];
          avatarData = await new Promise((resolve, reject) => {
            const r = new FileReader();
            r.onload = () => resolve(r.result);
            r.onerror = () => reject(r.error);
            r.readAsDataURL(file);
          });
        }
      } catch (e) { console.warn('Could not read provided profile picture', e); }

      await registerLanding(u, p, avatarData);
      // hide auth screen and update UI
      if (authScreen) authScreen.classList.add('hidden');
      // update profile name display instantly
      try { const stored = JSON.parse(sessionStorage.getItem('auth_user') || '{}'); if (stored && stored.username) { const userInfo = document.getElementById('userInfo'); if (userInfo) { userInfo.textContent = 'Welcome, ' + stored.username; userInfo.classList.remove('hidden'); } const loginHeaderBtn = document.getElementById('loginHeaderBtn'); if (loginHeaderBtn) loginHeaderBtn.classList.add('hidden'); const logoutBtn = document.getElementById('logoutBtn'); if (logoutBtn) logoutBtn.classList.remove('hidden'); if (window.showWelcomeToast) window.showWelcomeToast(stored.username); }} catch(e){}
      // after registering, ensure avatar is visible in UI
      try {
        const key = profileStorageKey(u);
        const pic = localStorage.getItem(key);
        if (pic) {
          const avatarImg = document.getElementById('profileAvatarImg');
          if (avatarImg) avatarImg.src = pic;
        }
      } catch (e) { /* ignore */ }
    } catch (err) {
      console.error('register error', err);
      document.getElementById('landingRegMsg').textContent = err.message === 'username_taken' ? 'username taken' : (err.message || 'Registration failed');
    }
  });

  // show auth screen on load if no auth_user
  const current = sessionStorage.getItem('auth_user');
  if (!current) {
    if (authScreen) authScreen.classList.remove('hidden');
    showLogin();
  } else {
    if (authScreen) authScreen.classList.add('hidden');
  }
});
</script>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, updateProfile } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
import { getFirestore, doc, setDoc } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyCuu2b0I2D4UX-tFJu-4dEXwZAU0Koui6U",
  authDomain: "jokes-on-you-ea61b.firebaseapp.com",
  projectId: "jokes-on-you-ea61b",
  storageBucket: "jokes-on-you-ea61b.firebasestorage.app",
  messagingSenderId: "831999849916",
  appId: "1:831999849916:web:d5b4ffff5ce09605c0a7b9",
  measurementId: "G-8TNMSY9H2G"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

// Register user
async function registerUser(username, password, profilePicUrl = "") {
  const email = username.includes('@') ? username : `${username}@jokesonyou.fake`;
  const userCredential = await createUserWithEmailAndPassword(auth, email, password);
  const user = userCredential.user;
  await updateProfile(user, { displayName: username, photoURL: profilePicUrl || undefined });
  await setDoc(doc(db, "users", user.uid), {
    username: username,
    email: email,
    profilePic: profilePicUrl || "",
    created: new Date().toISOString()
  });
  return user;
}

// Login user
async function loginUser(username, password) {
  const email = username.includes('@') ? username : `${username}@jokesonyou.fake`;
  const userCredential = await signInWithEmailAndPassword(auth, email, password);
  return userCredential.user;
}

window.addEventListener('DOMContentLoaded', () => {
  document.getElementById('landingRegBtn').addEventListener('click', async () => {
    const u = document.getElementById('landingRegUser').value.trim();
    const p = document.getElementById('landingRegPass').value;
    const p2 = document.getElementById('landingRegPass2').value;
    document.getElementById('landingRegMsg').textContent = '';
    if (!u) { document.getElementById('landingRegUserErr').textContent = 'Enter a username'; return; } else { document.getElementById('landingRegUserErr').textContent = ''; }
    if (!p || p.length < 6) { document.getElementById('landingRegPassErr').textContent = 'Password must be 6+ chars'; return; } else { document.getElementById('landingRegPassErr').textContent = ''; }
    if (p !== p2) { document.getElementById('landingRegPass2Err').textContent = 'Passwords do not match'; return; } else { document.getElementById('landingRegPass2Err').textContent = ''; }
    try {
      await registerUser(u, p);
      document.getElementById('landingRegMsg').textContent = 'Registration successful!';
    } catch (err) {
      console.error('register error', err);
      document.getElementById('landingRegMsg').textContent = err.message === 'username_taken' ? 'username taken' : (err.message || 'Registration failed');
    }
  });

  document.getElementById('landingLoginBtn').addEventListener('click', async () => {
    const u = document.getElementById('landingLoginUser').value.trim();
    const p = document.getElementById('landingLoginPass').value;
    document.getElementById('landingLoginMsg').textContent = '';
    try {
      await loginUser(u, p);
      document.getElementById('landingLoginMsg').textContent = 'Login successful!';
    } catch (err) {
      console.error('login error', err);
      document.getElementById('landingLoginMsg').textContent = err.message === 'wrong_credentials' ? 'wrong credentials' : (err.message || 'Login failed');
    }
  });
});
</script>

</body>
</html>
