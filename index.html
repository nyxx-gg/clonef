<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jokes On You — Screenshot Gallery</title>

<!-- Google Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Mansalva&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

<style>
  :root {
    --bg: #ffffff;
    --card: #797979;
    --muted: #6b7280;
    --gap: 1rem;
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    font-family: Inter, sans-serif;
    background: var(--bg);
    color: #272727;
  }

  header {
    padding: 2rem 1rem 1rem;
    text-align: center;
  }
  h1 {
    font-family: 'Mansalva', cursive;
    font-size: 77px;
    margin: 0;
    color: #000;
    line-height: 1;
    text-align: center;
    will-change: transform, font-size;
  }

  .gallery-wrap {
    padding: 1rem;
    width: 100%;
    max-width: 1400px;
    margin: auto;
  }

  /* Masonry using CSS columns */
  .gallery {
    column-gap: var(--gap);
    width: 100%;
    column-fill: balance;
  }
  @media (min-width:1400px){ .gallery{column-count:4;} }
  @media (min-width:1000px) and (max-width:1399px){ .gallery{column-count:3;} }
  @media (min-width:700px) and (max-width:999px){ .gallery{column-count:2;} }
  @media (max-width:699px){ .gallery{column-count:1;} }

  .item {
    display: inline-block;
    width: 100%;
    margin: 0 0 var(--gap);
    break-inside: avoid;
    /* make card background invisible while keeping rounded image corners */
    background: transparent;
    padding: 0;
    border-radius: 0;
    box-shadow: none;
  }
  .item img {
    width: 100%;
    border-radius: 12px; /* keep rounded corners on the image */
    display: block;
  }
  .item p {
    margin: .5rem 0 0;
    color: #000; /* caption text back-coloured (black) */
    font-size: .9rem;
    word-break: break-word;
  }

  .upload-box {
    background: #fff;
    color: #000;
    padding: 1rem 1.2rem;
    width: min(500px, 90%);
    border-radius: 18px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.3);
    display: flex;
    flex-direction: column;
    gap: .75rem;
  }

  .upload-box.dragover {
    outline: 3px dashed rgba(15,23,36,0.6);
    background: #fbfbfb;
  }

  /* small screens - tighter title size */
  @media (max-width:420px){
    h1{ font-size: 2.3rem; }
  }

  /* Search sidebar */
  .search-toggle {
    background: #0f1724;
    color: #fff;
    border-radius: 999px;
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 6px 18px rgba(0,0,0,0.2);
    cursor: pointer;
    z-index: 1100;
  }

  .search-panel {
    position: fixed;
    left: 0;
    top: 0;
    bottom: 0;
    width: 320px;
    background: #ffffff;
    box-shadow: 4px 0 24px rgba(0,0,0,0.12);
    transform: translateX(-100%);
    transition: transform 220ms ease;
    z-index: 1090;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: .75rem;
  }

  .search-panel.open { transform: translateX(0); }

  .search-panel input[type="search"] {
    width: 100%;
    padding: .6rem .8rem;
    border-radius: 8px;
    border: 1px solid #ddd;
    font-size: 1rem;
  }

  .search-panel .close-btn {
    background: transparent;
    border: none;
    color: #333;
    font-size: 1.1rem;
    cursor: pointer;
    align-self: flex-end;
  }

  .search-results {
    overflow: auto;
    flex: 1 1 auto;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: .6rem;
    align-items: start;
  }

  .search-result {
    display: flex;
    flex-direction: column;
    gap: .45rem;
    align-items: stretch;
    padding: .5rem;
    border-radius: 8px;
    border: 1px solid #f5f5f5;
    background: #fff;
    cursor: pointer;
  }

  .search-result img { width: 100%; height: 120px; object-fit: cover; border-radius: 8px; display: block; }
  .search-result .meta { font-size: .9rem; color: #333; line-height: 1.2; padding: 0 .15rem .25rem; text-align: left; }
  /* Left tools and add-panel styles */
  .left-tools { position: fixed; left: 12px; top: 50%; transform: translateY(-50%); display:flex; flex-direction:column; gap:.6rem; z-index:1110; }
  .add-toggle { background: #0f1724; color: #fff; border-radius: 999px; width:48px; height:48px; display:flex; align-items:center; justify-content:center; box-shadow:0 6px 18px rgba(0,0,0,0.2); cursor:pointer; border: none; }
  .add-panel { position: fixed; left: 0; top: 0; bottom: 0; width: 360px; background: #ffffff; box-shadow: 4px 0 24px rgba(0,0,0,0.12); transform: translateX(-100%); transition: transform 220ms ease; z-index: 1105; padding: 1rem; display: flex; flex-direction: column; gap: .75rem; }
  .add-panel.open { transform: translateX(0); }
  .add-panel.dragover { outline: 3px dashed rgba(15,23,36,0.6); background: #fbfbfb; }
  /* Lightbox / post view */
  .lightbox {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.6);
    z-index: 1200;
    padding: 2rem;
  }
  .lightbox.open { display: flex; }
  .lightbox-content {
    background: #fff;
    border-radius: 12px;
    max-width: 1100px;
    width: 100%;
    max-height: 90vh;
    overflow: auto;
    position: relative;
    box-shadow: 0 20px 60px rgba(0,0,0,0.4);
  }
  .lightbox-content img {
    display: block;
    width: 100%;
    height: auto;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
    object-fit: contain;
    background: #000;
  }
  .lightbox-caption {
    padding: 1rem;
    color: #222;
    font-size: 1rem;
  }
  .close-lightbox {
    position: absolute;
    right: 8px;
    top: 8px;
    background: rgba(15,23,36,0.95);
    color: #fff;
    border: none;
    width: 36px;
    height: 36px;
    border-radius: 999px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 1210;
  }
  /* Profile modal (post-sized view) */
  .profile-modal {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.6);
    z-index: 1250;
    padding: 2rem;
  }
  .profile-modal.open { display: flex; }
  .profile-content {
    background: #fff;
    border-radius: 12px;
    width: 100%;
    max-width: 900px;
    max-height: 85vh;
    position: relative;
    padding: 1.25rem 1.5rem 2rem;
    box-shadow: 0 30px 80px rgba(0,0,0,0.45);
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  .profile-close {
    position: absolute;
    right: 12px;
    top: 12px;
    background: transparent;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    color: #666;
  }
  .profile-top { display: flex; flex-direction: column; align-items: center; gap: .5rem; padding-top: .6rem; flex: 0 0 auto; }
  .profile-avatar { width: 96px; height: 96px; border-radius: 999px; background: #f0f0f0; display:flex; align-items:center; justify-content:center; overflow: hidden; cursor: pointer; border: 4px solid #fff; box-shadow: 0 6px 20px rgba(0,0,0,0.08); }
  .profile-avatar img { width: 100%; height: 100%; object-fit: cover; display: block; }
  .profile-username { font-family: 'Mansalva', cursive; font-size: 28px; margin-top: .35rem; color: #000; }

  .profile-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1rem; flex: 1 1 auto; overflow: auto; padding-bottom: 0.5rem; }
  @media (max-width:800px) { .profile-grid { grid-template-columns: repeat(2, 1fr); } }
  @media (max-width:420px) { .profile-grid { grid-template-columns: 1fr; } }
  .profile-item { display: flex; flex-direction: column; gap: .4rem; align-items: center; }
  .profile-item img { width: 100%; height: 120px; object-fit: cover; border-radius: 12px; display: block; }
  .profile-item .cap { font-size: .95rem; color: #222; text-align: center; margin-top: .25rem; }

  /* hidden file input for avatar upload */
  #profilePicInput { display: none; }
  /* Crop modal */
  .crop-modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.6); z-index: 1300; padding: 2rem; }
  .crop-modal.open { display: flex; }
  .crop-card { background: #fff; border-radius: 12px; padding: 1rem; width: 100%; max-width: 520px; box-shadow: 0 30px 80px rgba(0,0,0,0.4); display:flex; flex-direction:column; gap:.75rem; }
  .crop-viewport { width: 360px; height: 360px; max-width: calc(100% - 40px); background: #111; margin: 0 auto; overflow: hidden; position: relative; border-radius: 8px; }
  .crop-viewport img { position: absolute; top:0; left:0; user-select: none; touch-action: none; cursor: grab; }
  .crop-controls { display:flex; gap:.5rem; align-items:center; justify-content:center; }
  .crop-controls input[type=range] { width: 60%; }
  .crop-actions { display:flex; gap:.5rem; justify-content:flex-end; }
  /* Welcome toast */
  .welcome-toast {
    font-family: 'Mansalva', cursive;
    position: fixed;
    left: 50%;
    bottom: 24px;
    transform: translateX(-50%) translateY(100%);
    background: rgba(15,23,36,0.95);
    color: #fff;
    padding: 10px 18px;
    border-radius: 999px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.35);
    font-size: 20px;
    z-index: 2000;
    opacity: 0;
  }
  @keyframes slideWelcome {
    0% { transform: translateX(-50%) translateY(100%); opacity: 0; }
    15% { transform: translateX(-50%) translateY(0%); opacity: 1; }
    85% { transform: translateX(-50%) translateY(0%); opacity: 1; }
    100% { transform: translateX(-50%) translateY(100%); opacity: 0; }
  }
  .welcome-toast.animate { animation: slideWelcome 1s ease forwards; }
  /* utility hidden class */
  .hidden { display: none !important; }

  /* Fullscreen auth landing (login/register) */
  .auth-screen {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #ffffff;
    z-index: 1600;
    padding: 2rem;
  }
  .auth-screen.hidden { display: none; }
  .auth-card {
    width: 100%;
    max-width: 480px;
    border-radius: 12px;
    padding: 2rem;
    box-shadow: 0 20px 60px rgba(0,0,0,0.12);
    background: #fff;
  }
  .auth-tabs { display:flex; gap: .5rem; margin-bottom: 1rem; }
  .auth-tabs button { flex:1; padding: .6rem; border-radius: 8px; border:1px solid #eee; background:#fafafa; cursor:pointer; }
  .auth-tabs button.active { background: #0f1724; color:#fff; border-color: rgba(0,0,0,0.06); }
  .auth-form .form-row { margin-bottom: .9rem; }
  .auth-form label { display:block; font-size:.9rem; margin-bottom:.25rem; color:#333; }
  .auth-form input { width:100%; padding:.65rem .8rem; border-radius:8px; border:1px solid #ddd; }
  .auth-form .error { color:#d32f2f; font-size:.85rem; margin-top:.35rem; }
  .auth-actions { margin-top: .6rem; }
</style>
</head>
<body>
 
    <div class="left-tools" aria-hidden="false">
      <button class="search-toggle" id="profileToggle" aria-label="Open profile">
        <!-- user/profile icon -->
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="12" cy="7" r="4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <button class="search-toggle" id="searchToggle" aria-label="Open search">
        <!-- simple search icon -->
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M21 21l-4.35-4.35" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="11" cy="11" r="6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
  
      <button class="add-toggle" id="addToggle" aria-label="Open uploader">
        <!-- plus icon -->
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <path d="M12 5v14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
    </div>

  <aside class="search-panel" id="searchPanel" aria-hidden="true" aria-label="Search uploads">
    <button class="close-btn" id="searchClose" aria-label="Close search">✕</button>
    <label for="searchInput" style="font-size:.9rem;color:#444">Search Posts</label>
    <input id="searchInput" type="search" placeholder="Search by description or filename" aria-label="Search uploaded files">
    <div id="searchCount" style="color:#666;font-size:.9rem">0 results</div>
    <div class="search-results" id="searchResults" role="list"></div>
  </aside>

  <aside class="add-panel" id="addPanel" aria-hidden="true" aria-label="Add upload">
    <button class="close-btn" id="addClose" aria-label="Close uploader">✕</button>
    <label for="addFileInput" style="font-size:.9rem;color:#444">Upload image</label>
    <input id="addFileInput" type="file" accept="image/*" aria-label="Choose image to upload">
    <textarea id="addDescInput" rows="3" placeholder="Write a caption..." aria-label="Image description"></textarea>
    <button id="addUploadBtn" type="button" aria-label="Upload image">Upload</button>
  </aside>

  <!-- Lightbox / single-post modal -->
  <div class="lightbox" id="lightbox" role="dialog" aria-hidden="true">
    <div class="lightbox-content" role="document">
      <button class="close-lightbox" id="closeLightbox" aria-label="Close post">✕</button>
      <img id="lightboxImg" src="" alt="" />
      <div class="lightbox-caption" id="lightboxCaption"></div>
    </div>
  </div>

  <!-- Profile modal (user's profile and posts) -->
  <div class="profile-modal" id="profileModal" role="dialog" aria-hidden="true">
    <div class="profile-content">
      <button class="profile-close" id="closeProfile" aria-label="Close profile">✕</button>
      <div class="profile-top">
        <div class="profile-avatar" id="profileAvatar" title="Click to change profile picture">
          <!-- default avatar (will be replaced if user uploads one) -->
          <img id="profileAvatarImg" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'><rect width='100%' height='100%' fill='%23f0f0f0'/><circle cx='100' cy='74' r='48' fill='%23000'/><rect x='40' y='120' width='120' height='48' rx='8' fill='%23000'/></svg>" alt="Profile">
        </div>
        <div class="profile-username" id="profileName">Username</div>
      </div>

      <input id="profilePicInput" type="file" accept="image/*" aria-label="Choose profile picture">

      <div class="profile-grid" id="profileGrid">
        <!-- user posts will be inserted here dynamically -->
      </div>
    </div>
  </div>

  <!-- Crop modal for profile picture -->
  <div class="crop-modal" id="cropModal" role="dialog" aria-hidden="true">
    <div class="crop-card">
      <div style="text-align:center;font-weight:600">Crop profile picture</div>
      <div class="crop-viewport" id="cropViewport">
        <img id="cropImage" src="" alt="to crop">
      </div>
      <div class="crop-controls">
        <label style="font-size:.9rem">Zoom</label>
        <input id="cropZoom" type="range" min="1" max="3" step="0.01" value="1">
      </div>
      <div class="crop-actions">
        <button id="cropCancel" type="button">Cancel</button>
        <button id="cropDone" type="button">Done</button>
      </div>
    </div>
  </div>

<header>
  <h1>Jokes On You</h1>
</header>

<!-- Fullscreen auth landing shown when not logged in -->
<div class="auth-screen" id="authScreen" role="dialog" aria-hidden="false">
  <div class="auth-card" role="document">
    <div class="auth-tabs">
      <button id="tabLogin" class="active" type="button">Login</button>
      <button id="tabRegister" type="button">Register</button>
    </div>

    <div id="loginBox" class="auth-form">
      <div class="form-row">
        <label for="landingLoginUser">Username</label>
        <input id="landingLoginUser" type="text" autocomplete="username">
        <div class="error" id="landingLoginUserErr"></div>
      </div>
      <div class="form-row">
        <label for="landingLoginPass">Password</label>
        <input id="landingLoginPass" type="password" autocomplete="current-password">
        <div class="error" id="landingLoginPassErr"></div>
      </div>
      <div class="form-row auth-actions">
        <button id="landingLoginBtn" type="button">Login</button>
      </div>
      <div class="form-row"><small id="landingLoginMsg" class="error"></small></div>
    </div>

    <div id="registerBox" class="auth-form hidden">
      <div class="form-row">
        <label for="landingRegUser">Username</label>
        <input id="landingRegUser" type="text" autocomplete="username">
        <div class="error" id="landingRegUserErr"></div>
      </div>
      <div class="form-row">
        <label for="landingRegPass">Password</label>
        <input id="landingRegPass" type="password" autocomplete="new-password">
        <div class="error" id="landingRegPassErr"></div>
      </div>
      <div class="form-row">
        <label for="landingRegPass2">Repeat Password</label>
        <input id="landingRegPass2" type="password" autocomplete="new-password">
        <div class="error" id="landingRegPass2Err"></div>
      </div>
      <div class="form-row">
        <label for="landingRegPic">Profile picture (optional)</label>
        <input id="landingRegPic" type="file" accept="image/*">
      </div>
      <div class="form-row auth-actions">
        <button id="landingRegBtn" type="button">Create account</button>
      </div>
      <div class="form-row"><small id="landingRegMsg" class="error"></small></div>
    </div>
  </div>
</div>

<main class="gallery-wrap">
  <!-- Masonry Gallery -->
  <div id="gallery" class="gallery" aria-live="polite"></div>
</main>

<script>
/* ========== Configuration ========== */
/* Set this later to your deployed Google Apps Script Web App URL */
const BACKEND_URL = ""; // e.g. "https://script.google.com/macros/s/XXXXX/exec"

/* Max file size in bytes (default 15 MB). Adjust if you want bigger/smaller uploads. */
const MAX_FILE_SIZE = 15 * 1024 * 1024;

/* ========== Helpers ========== */

/* Create gallery item safely (no innerHTML with user strings) */
function createGalleryItem(imageSrc, description, filename) {
  const item = document.createElement('div');
  item.className = 'item';
  // store searchable data attributes
  
  item.dataset.desc = (description || '').toLowerCase();
  item.dataset.filename = (filename || '').toLowerCase();

  const img = document.createElement('img');
  img.src = imageSrc;
  img.alt = description ? description.slice(0, 100) : (filename || 'screenshot');
  img.loading = 'lazy';
  item.appendChild(img);

  if (description) {
    const p = document.createElement('p');
    p.textContent = description;
    item.appendChild(p);
  }

  return item;
}

/* Add an image at the top of the gallery */
function addImageToGallery(imageSrc, description, filename) {
  const gallery = document.getElementById('gallery');
  const item = createGalleryItem(imageSrc, description, filename);
  // attach owner metadata when available (session-only auth)
  try {
    const auth = JSON.parse(sessionStorage.getItem('auth_user') || '{}');
    if (auth && auth.username) item.dataset.owner = auth.username.toString();
  } catch (e) { /* ignore */ }
  // prepend - newest at top
  gallery.insertBefore(item, gallery.firstChild);
  // if search panel is open and a query exists, re-run search so newly added items are accounted for
  const searchPanel = document.getElementById('searchPanel');
  const searchInput = document.getElementById('searchInput');
  if (searchPanel && searchPanel.classList.contains('open') && searchInput && searchInput.value.trim()) {
    performSearch(searchInput.value.trim());
  }
}

/* Safe base64 extraction from FileReader result */
function extractBase64(dataUrl) {
  if (!dataUrl) return '';
  const comma = dataUrl.indexOf(',');
  return comma >= 0 ? dataUrl.slice(comma + 1) : dataUrl;
}

/* ========== Upload flow ========== */

async function upload() {
  const fileInput = document.getElementById('fileInput');
  const descInput = document.getElementById('descInput');

  if (!fileInput.files || !fileInput.files[0]) {
    alert('Please choose an image file to upload.');
    return;
  }

  const file = fileInput.files[0];

  if (file.size > MAX_FILE_SIZE) {
    alert(`File is too large. Maximum size is ${Math.round(MAX_FILE_SIZE / 1024 / 1024)} MB.`);
    return;
  }
  // delegate reading and uploading to shared helper
  await processFile(file, descInput.value || '');

  // reset inputs
  fileInput.value = '';
  descInput.value = '';
}

/* Process a File object: read as DataURL, optionally POST to backend, then add to gallery */
async function processFile(file, description) {
  if (!file) return;
  if (file.size > MAX_FILE_SIZE) {
    alert(`File is too large. Maximum size is ${Math.round(MAX_FILE_SIZE / 1024 / 1024)} MB.`);
    return;
  }

  const reader = new FileReader();

  reader.onerror = function() {
    console.error('FileReader failed', reader.error);
    alert('Failed to read the file.');
  };

  reader.onload = async function(e) {
    const dataUrl = e.target.result;
    const base64 = extractBase64(dataUrl);
    const desc = (description || '').trim();

    if (BACKEND_URL) {
      try {
        const body = new URLSearchParams({ file: base64, filename: file.name, desc });
        const res = await fetch(BACKEND_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8' },
          body
        });

        if (!res.ok) {
          console.error('Upload failed', res.status, await res.text());
          alert('Upload failed. Check console for details.');
          return;
        }

        const text = await res.text();
        let imageUrl = text;
        try {
          const json = JSON.parse(text);
          imageUrl = json.url || json.imageUrl || json.link || text;
        } catch (_) { /* not JSON */ }

        addImageToGallery(imageUrl, desc, file.name);
      } catch (err) {
        console.error('Upload error', err);
        alert('Upload failed (network). Check console.');
      }
    } else {
      addImageToGallery(dataUrl, desc, file.name);
    }
  };

  reader.readAsDataURL(file);
}

/* ========== Load existing images on startup (placeholder) ========== */
async function loadImages() {
  // If you implement a GET endpoint on your Apps Script, fetch it and return
  // an array like: [{ url: 'https://...', desc:'...', filename:'...'}, ...]
  if (!BACKEND_URL) return;

  try {
    const res = await fetch(BACKEND_URL + "?action=list"); // change to how you implement it
    if (!res.ok) {
      console.warn('Could not fetch existing images:', res.status);
      return;
    }
    const payload = await res.json(); // expected array
    if (!Array.isArray(payload)) return;

    // Add in reverse so newest show first (optional)
    payload.reverse().forEach(file => {
      if (file.url) addImageToGallery(file.url, file.desc || '', file.filename || '');
    });
  } catch (err) {
    console.error('Error loading images:', err);
  }
}

/* ========== Wiring ========== */
document.addEventListener('DOMContentLoaded', function() {
  loadImages();
  // capture the originally-rendered default avatar so we can restore it
  try {
    const pa = document.getElementById('profileAvatarImg');
    if (pa && !window.__DEFAULT_PROFILE_AVATAR) window.__DEFAULT_PROFILE_AVATAR = pa.src;
  } catch (e) { /* ignore */ }
  // Search UI wiring
  const searchToggle = document.getElementById('searchToggle');
  const searchPanel = document.getElementById('searchPanel');
  const searchClose = document.getElementById('searchClose');
  const searchInput = document.getElementById('searchInput');

  function openSearch() {
    searchPanel.classList.add('open');
    searchPanel.setAttribute('aria-hidden', 'false');
    setTimeout(() => searchInput.focus(), 220);
  }
  function closeSearch() {
    searchPanel.classList.remove('open');
    searchPanel.setAttribute('aria-hidden', 'true');
    searchInput.value = '';
    performSearch('');
  }

  searchToggle.addEventListener('click', () => { if (searchPanel.classList.contains('open')) closeSearch(); else openSearch(); });
  searchClose.addEventListener('click', closeSearch);
  searchInput.addEventListener('input', (e) => performSearch(e.target.value.trim()));

  // Drag & drop support (document + upload box)
  const uploadBox = document.querySelector('.upload-box');
  const descInput = document.getElementById('descInput');
  const fileInput = document.getElementById('fileInput');
  let pendingFile = null; // store file from drag/drop or paste

  function preventAndStop(e) { e.preventDefault(); e.stopPropagation(); }

  // Prevent default browser behavior for drag/drop so files don't open in the window
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
    document.addEventListener(evt, preventAndStop, false);
  });

  // Visual feedback on upload box
  if (uploadBox) {
    uploadBox.addEventListener('dragover', (e) => { e.preventDefault(); uploadBox.classList.add('dragover'); });
    uploadBox.addEventListener('dragleave', (e) => { e.preventDefault(); uploadBox.classList.remove('dragover'); });
    uploadBox.addEventListener('drop', (e) => {
      e.preventDefault(); uploadBox.classList.remove('dragover');
      const dt = e.dataTransfer;
      if (!dt) return;
      const files = Array.from(dt.files || []);
      if (files.length > 0) {
        // Store the first image file and focus on caption
        const imageFile = files.find(f => f.type.indexOf('image') !== -1);
        if (imageFile) {
          pendingFile = imageFile;
          updateFileInputDisplay(imageFile, fileInput);
          descInput.focus();
          descInput.placeholder = `Caption for: ${imageFile.name}`;
        }
      }
    });
  }

  // Add-panel drag & drop handling (so users can drop directly into the add panel)
  const addPanelEl = document.getElementById('addPanel');
  if (addPanelEl) {
    addPanelEl.addEventListener('dragover', (e) => { e.preventDefault(); addPanelEl.classList.add('dragover'); });
    addPanelEl.addEventListener('dragleave', (e) => { e.preventDefault(); addPanelEl.classList.remove('dragover'); });
    addPanelEl.addEventListener('drop', (e) => {
      e.preventDefault(); addPanelEl.classList.remove('dragover');
      const dt = e.dataTransfer;
      if (!dt) return;
      const files = Array.from(dt.files || []);
      const imageFile = files.find(f => f.type.indexOf('image') !== -1);
      if (imageFile) {
        pendingFile = imageFile;
        const addFile = document.getElementById('addFileInput');
        const addDesc = document.getElementById('addDescInput');
        updateFileInputDisplay(imageFile, addFile);
        addDesc.focus();
        addDesc.placeholder = `Caption for: ${imageFile.name}`;
      }
    });
  }

  // Allow dropping anywhere on document (only if not on upload box)
  document.addEventListener('drop', (e) => {
    if (e.target.closest('.upload-box')) return; // let upload-box handler take it
    const dt = e.dataTransfer;
    if (!dt) return;
    const files = Array.from(dt.files || []);
    if (files.length === 0) return;
    const imageFile = files.find(f => f.type.indexOf('image') !== -1);
    if (imageFile) {
      pendingFile = imageFile;
      updateFileInputDisplay(imageFile, fileInput);
      descInput.focus();
      descInput.placeholder = `Caption for: ${imageFile.name}`;
    }
  });

  // Paste from clipboard (images)
  document.addEventListener('paste', (e) => {
    const clipboard = e.clipboardData || window.clipboardData;
    if (!clipboard) return;
    const items = Array.from(clipboard.items || []);
    const filesFromClipboard = Array.from(clipboard.files || []);
    
    // Check clipboard.files first
    if (filesFromClipboard.length) {
      const imageFile = filesFromClipboard.find(f => f.type.indexOf('image') !== -1);
      if (imageFile) {
        // if add panel is open, set its file input instead
        const addPanelEl = document.getElementById('addPanel');
        if (addPanelEl && addPanelEl.classList.contains('open')) {
          const addFile = document.getElementById('addFileInput');
          const addDesc = document.getElementById('addDescInput');
          pendingFile = imageFile;
          updateFileInputDisplay(imageFile, addFile);
          addDesc.focus();
          addDesc.placeholder = 'Write caption and press Enter to upload...';
        } else {
          pendingFile = imageFile;
          updateFileInputDisplay(imageFile, fileInput);
          descInput.focus();
          descInput.placeholder = 'Write caption and press Enter to upload...';
        }
      }
      return;
    }

    // Check clipboard items for images
    items.forEach(item => {
      if (item.kind === 'file' && item.type.indexOf('image') !== -1) {
        const file = item.getAsFile();
        if (file) {
          const addPanelEl = document.getElementById('addPanel');
          if (addPanelEl && addPanelEl.classList.contains('open')) {
            const addFile = document.getElementById('addFileInput');
            const addDesc = document.getElementById('addDescInput');
            pendingFile = file;
            updateFileInputDisplay(file, addFile);
            addDesc.focus();
            addDesc.placeholder = 'Write caption and press Enter to upload...';
          } else {
            pendingFile = file;
            updateFileInputDisplay(file, fileInput);
            descInput.focus();
            descInput.placeholder = 'Write caption and press Enter to upload...';
          }
        }
      }
    });
  });

  // Helper to update file input display with a pending file (targetInput optional)
  function updateFileInputDisplay(file, targetInput) {
    if (!file) return;
    try {
      const dataTransfer = new DataTransfer();
      dataTransfer.items.add(file);
      const inputEl = targetInput || fileInput;
      if (inputEl) inputEl.files = dataTransfer.files;
    } catch (err) {
      console.warn('Could not update file input display:', err);
    }
  }

  // Add Enter key handler on caption textarea to upload pending file
  if (descInput) {
    descInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        if (pendingFile) {
          // Upload the pending file with the caption
          processFile(pendingFile, descInput.value);
          pendingFile = null;
          descInput.value = '';
          descInput.placeholder = 'Write a caption...';
          // Reset file input display
          fileInput.value = '';
        } else if (fileInput.files && fileInput.files[0]) {
          // Standard upload via file input
          upload();
        }
      }
    });
  }

  // Title shrink/translate behavior on scroll
  const title = document.querySelector('header h1');
  const TITLE_MAX = 77; // px
  const TITLE_MIN = 45; // px
  const SCROLL_THRESHOLD = 200; // px of scroll when title reaches min size

  function applyTitleTransform(scrollY) {
    if (!title) return;
    const progress = Math.min(Math.max(scrollY / SCROLL_THRESHOLD, 0), 1);
    const size = TITLE_MAX - (TITLE_MAX - TITLE_MIN) * progress;
    const translateY = -30 * progress; // move up by up to 30px
    title.style.fontSize = size + 'px';
    title.style.transform = `translateY(${translateY}px)`;
  }

  let ticking = false;
  window.addEventListener('scroll', () => {
    if (!ticking) {
      window.requestAnimationFrame(() => {
        applyTitleTransform(window.scrollY || window.pageYOffset);
        ticking = false;
      });
      ticking = true;
    }
  });

  // initialize on load
  applyTitleTransform(window.scrollY || window.pageYOffset);

  // Add panel wiring
  const addToggle = document.getElementById('addToggle');
  const addPanel = document.getElementById('addPanel');
  const addClose = document.getElementById('addClose');
  const addFileInput = document.getElementById('addFileInput');
  const addDescInput = document.getElementById('addDescInput');
  const addUploadBtn = document.getElementById('addUploadBtn');

  function openAdd() {
    // close search if open
    if (searchPanel && searchPanel.classList.contains('open')) closeSearch();
    addPanel.classList.add('open');
    addPanel.setAttribute('aria-hidden', 'false');
    setTimeout(() => addFileInput.focus(), 200);
  }
  function closeAdd() {
    addPanel.classList.remove('open');
    addPanel.setAttribute('aria-hidden', 'true');
    // reset fields
    addFileInput.value = '';
    addDescInput.value = '';
  }

  if (addToggle) addToggle.addEventListener('click', () => { if (addPanel.classList.contains('open')) closeAdd(); else openAdd(); });
  if (addClose) addClose.addEventListener('click', closeAdd);

  if (addUploadBtn) addUploadBtn.addEventListener('click', () => {
    const f = addFileInput.files && addFileInput.files[0];
    const desc = addDescInput.value.trim();
    if (!f) { alert('Please choose an image to upload.'); return; }
    processFile(f, desc);
    closeAdd();
  });

  // allow Enter in addDescInput to submit
  if (addDescInput) addDescInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      addUploadBtn.click();
    }
  });

  // Lightbox: open when clicking a gallery image
  const lightbox = document.getElementById('lightbox');
  const lightboxImg = document.getElementById('lightboxImg');
  const lightboxCaption = document.getElementById('lightboxCaption');
  const closeLightboxBtn = document.getElementById('closeLightbox');

  function openLightbox(src, caption, alt) {
    if (!lightbox) return;
    lightboxImg.src = src || '';
    lightboxImg.alt = alt || '';
    lightboxCaption.textContent = caption || '';
    lightbox.classList.add('open');
    lightbox.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
    closeLightboxBtn.focus();
  }

  function closeLightbox() {
    if (!lightbox) return;
    lightbox.classList.remove('open');
    lightbox.setAttribute('aria-hidden', 'true');
    lightboxImg.src = '';
    lightboxCaption.textContent = '';
    document.body.style.overflow = '';
  }

  // expose lightbox controls to the global scope so other code (e.g. search) can open/close it
  window.openLightbox = openLightbox;
  window.closeLightbox = closeLightbox;

  // Delegated click handler on gallery
  const galleryEl = document.getElementById('gallery');
  if (galleryEl) {
    galleryEl.addEventListener('click', (e) => {
      const img = e.target.closest('img');
      if (!img) return;
      const item = img.closest('.item');
      const descEl = item ? item.querySelector('p') : null;
      const caption = descEl ? descEl.textContent : '';
      openLightbox(img.src, caption, img.alt || 'image');
    });
  }

  // close handlers
  if (closeLightboxBtn) closeLightboxBtn.addEventListener('click', closeLightbox);
  if (lightbox) lightbox.addEventListener('click', (e) => { if (e.target === lightbox) closeLightbox(); });
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeLightbox(); });

});

/* Search logic: filters gallery and populates the side results */
function performSearch(query) {
  const gallery = document.getElementById('gallery');
  const resultsContainer = document.getElementById('searchResults');
  const countEl = document.getElementById('searchCount');
  if (!gallery || !resultsContainer) return;

  const q = (query || '').toLowerCase();
  resultsContainer.innerHTML = '';
  let matchCount = 0;

  Array.from(gallery.children).forEach(item => {
    const desc = item.dataset.desc || '';
    const fname = item.dataset.filename || '';
    const isMatch = q === '' || desc.includes(q) || fname.includes(q);
    item.style.display = isMatch ? 'inline-block' : 'none';
    if (isMatch && q !== '') {
      // add to side results: small thumbnail + text
      const thumb = document.createElement('div');
      thumb.className = 'search-result';
      const img = item.querySelector('img');
      const clone = document.createElement('img');
      clone.src = img ? img.src : '';
      clone.alt = img ? img.alt : '';
      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = (item.querySelector('p') ? item.querySelector('p').textContent : fname) || fname || 'file';
      thumb.appendChild(clone);
      thumb.appendChild(meta);
      thumb.addEventListener('click', () => {
        // Open the matched post in the same lightbox used on the homepage
        const imgEl = item.querySelector('img');
        const descEl = item.querySelector('p');
        const caption = descEl ? descEl.textContent : '';
        if (imgEl && window.openLightbox) {
          window.openLightbox(imgEl.src, caption, imgEl.alt || 'image');
        } else if (imgEl) {
          // fallback: scroll into view
          item.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // close search panel after opening
        const sp = document.getElementById('searchPanel');
        if (sp && sp.classList.contains('open')) {
          sp.classList.remove('open');
          sp.setAttribute('aria-hidden', 'true');
          const searchInput = document.getElementById('searchInput');
          if (searchInput) searchInput.value = '';
        }
      });
      resultsContainer.appendChild(thumb);
      matchCount++;
    }
  });

  // update count
  if (countEl) countEl.textContent = q === '' ? '' : `${matchCount} result${matchCount === 1 ? '' : 's'}`;
}

/* ========== Profile view (frontend only hooks) ========== */

// Open profile modal
function openProfile() {
  const pm = document.getElementById('profileModal');
  if (!pm) return;
  // populate username and avatar from localStorage or placeholder
  const nameEl = document.getElementById('profileName');
  const avatarImg = document.getElementById('profileAvatarImg');
  const storedUser = sessionStorage.getItem('auth_user');
  let username = 'Username';
  if (storedUser) {
    try { username = JSON.parse(storedUser).username || username; } catch(e){}
  }
  nameEl.textContent = username;
  // load per-user profile pic if available. Do NOT fall back to the global
  // legacy `profile_pic` for logged-in users (that caused shared avatars).
  try {
    const authNow = JSON.parse(sessionStorage.getItem('auth_user') || '{}');
    if (authNow && authNow.username) {
      const key = profileStorageKey(authNow.username);
      const storedPic = localStorage.getItem(key);
      if (storedPic) avatarImg.src = storedPic;
      else avatarImg.src = window.__DEFAULT_PROFILE_AVATAR || avatarImg.src;
    } else {
      // when not logged-in, fall back to legacy key if present, otherwise default
      const storedPic = localStorage.getItem('profile_pic');
      if (storedPic) avatarImg.src = storedPic;
      else avatarImg.src = window.__DEFAULT_PROFILE_AVATAR || avatarImg.src;
    }
  } catch (e) {
    avatarImg.src = window.__DEFAULT_PROFILE_AVATAR || avatarImg.src;
  }

  // build profile grid: attempt to show items that belong to the user (dataset.owner)
  const grid = document.getElementById('profileGrid');
  grid.innerHTML = '';
  const gallery = document.getElementById('gallery');
  if (gallery) {
    const items = Array.from(gallery.children);
    // prefer items with matching owner metadata; fallback: show recent items
    const owned = items.filter(it => (it.dataset.owner || '').toLowerCase() === (username || '').toLowerCase());
    // Show all owned items; if none are found, show all recent items (not limited to 12)
    const toShow = owned.length ? owned : items;
    toShow.forEach(it => {
      const img = it.querySelector('img');
      const cap = it.querySelector('p');
      const tile = document.createElement('div');
      tile.className = 'profile-item';
      const thumb = document.createElement('img');
      thumb.src = img ? img.src : '';
      thumb.alt = img ? img.alt : 'post';
      thumb.addEventListener('click', () => {
        // open in lightbox and close profile
        if (window.openLightbox) window.openLightbox(thumb.src, cap ? cap.textContent : '', thumb.alt || 'image');
        closeProfile();
      });
      const caption = document.createElement('div');
      caption.className = 'cap';
      caption.textContent = cap ? cap.textContent : '';
      tile.appendChild(thumb);
      tile.appendChild(caption);
      grid.appendChild(tile);
    });
  }

  pm.classList.add('open');
  pm.setAttribute('aria-hidden', 'false');
  document.body.style.overflow = 'hidden';
}

function closeProfile() {
  const pm = document.getElementById('profileModal');
  if (!pm) return;
  pm.classList.remove('open');
  pm.setAttribute('aria-hidden', 'true');
  document.body.style.overflow = '';
}

// handle clicking avatar to upload a new profile picture (frontend-only)
document.addEventListener('DOMContentLoaded', () => {
  const profileToggle = document.getElementById('profileToggle');
  if (profileToggle) profileToggle.addEventListener('click', openProfile);

  const profileAvatar = document.getElementById('profileAvatar');
  const profilePicInput = document.getElementById('profilePicInput');
  const closeProfileBtn = document.getElementById('closeProfile');

  if (profileAvatar && profilePicInput) {
    profileAvatar.addEventListener('click', () => profilePicInput.click());
    profilePicInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        const src = ev.target.result;
        // open crop modal
        const cropModal = document.getElementById('cropModal');
        const cropImg = document.getElementById('cropImage');
        const zoom = document.getElementById('cropZoom');
        if (!cropModal || !cropImg || !zoom) return;
        cropImg.src = src;
        // reset transforms
        cropImg.style.transform = '';
        cropImg.style.left = '0px';
        cropImg.style.top = '0px';
        zoom.value = 1;
        cropModal.classList.add('open');
        cropModal.setAttribute('aria-hidden', 'false');
        // prepare dragging/zoom logic
        setupCropInteractions();
      };
      reader.readAsDataURL(f);
    });
  }

  if (closeProfileBtn) closeProfileBtn.addEventListener('click', closeProfile);
  // close when clicking the overlay
  const pm = document.getElementById('profileModal');
  if (pm) pm.addEventListener('click', (e) => { if (e.target === pm) closeProfile(); });
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeProfile(); });
});

// Crop modal interactions (drag image and zoom then crop)
function setupCropInteractions() {
  const cropModal = document.getElementById('cropModal');
  const cropViewport = document.getElementById('cropViewport');
  const cropImg = document.getElementById('cropImage');
  const zoomInput = document.getElementById('cropZoom');
  const cancelBtn = document.getElementById('cropCancel');
  const doneBtn = document.getElementById('cropDone');
  if (!cropModal || !cropViewport || !cropImg || !zoomInput) return;

  // state
  let isPointerDown = false;
  let startX = 0, startY = 0;
  let imgLeft = 0, imgTop = 0;
  let baseScale = 1; // initial fit scale
  let scale = 1;

  function resetPosition() {
    // compute natural size and fit center
    const naturalW = cropImg.naturalWidth || cropImg.width;
    const naturalH = cropImg.naturalHeight || cropImg.height;
    const vw = cropViewport.clientWidth;
    const vh = cropViewport.clientHeight;
    // fit to cover: ensure image covers viewport
    const fitScale = Math.max(vw / naturalW, vh / naturalH);
    baseScale = fitScale;
    scale = 1;
    zoomInput.value = 1;
    const displayW = naturalW * baseScale;
    const displayH = naturalH * baseScale;
    imgLeft = (vw - displayW) / 2;
    imgTop = (vh - displayH) / 2;
    applyTransform();
  }

  function applyTransform() {
    const s = baseScale * scale;
    cropImg.style.width = (cropImg.naturalWidth * s) + 'px';
    cropImg.style.height = (cropImg.naturalHeight * s) + 'px';
    cropImg.style.left = imgLeft + 'px';
    cropImg.style.top = imgTop + 'px';
  }

  function onPointerDown(e) {
    e.preventDefault();
    isPointerDown = true;
    startX = e.clientX || (e.touches && e.touches[0].clientX);
    startY = e.clientY || (e.touches && e.touches[0].clientY);
    cropImg.style.cursor = 'grabbing';
  }
  function onPointerMove(e) {
    if (!isPointerDown) return;
    const x = e.clientX || (e.touches && e.touches[0].clientX);
    const y = e.clientY || (e.touches && e.touches[0].clientY);
    const dx = x - startX;
    const dy = y - startY;
    startX = x; startY = y;
    imgLeft += dx; imgTop += dy;
    applyTransform();
  }
  function onPointerUp() { isPointerDown = false; cropImg.style.cursor = 'grab'; }

  // zoom change
  zoomInput.oninput = function() {
    const prevScale = scale;
    scale = parseFloat(zoomInput.value) || 1;
    // adjust imgLeft/imgTop so center stays approximately the same
    const vw = cropViewport.clientWidth;
    const vh = cropViewport.clientHeight;
    const cx = vw/2 - imgLeft;
    const cy = vh/2 - imgTop;
    const ratio = (baseScale * scale) / (baseScale * prevScale);
    imgLeft = vw/2 - cx * ratio;
    imgTop = vh/2 - cy * ratio;
    applyTransform();
  };

  // attach events
  cropImg.addEventListener('mousedown', onPointerDown);
  window.addEventListener('mousemove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);
  // touch
  cropImg.addEventListener('touchstart', onPointerDown, {passive:false});
  window.addEventListener('touchmove', onPointerMove, {passive:false});
  window.addEventListener('touchend', onPointerUp);

  // when image loads, reset position
  if (cropImg.complete) resetPosition();
  else cropImg.onload = resetPosition;

  // cancel
  if (cancelBtn) cancelBtn.onclick = function() { cropModal.classList.remove('open'); cropModal.setAttribute('aria-hidden','true'); };

  // done: perform crop and set avatar
      if (doneBtn) doneBtn.onclick = function() {
    try {
      const vw = cropViewport.clientWidth;
      const vh = cropViewport.clientHeight;
      const s = baseScale * scale;
      const naturalW = cropImg.naturalWidth;
      const naturalH = cropImg.naturalHeight;
      // top-left in natural coords
      const nx = Math.max(0, (-imgLeft) / s);
      const ny = Math.max(0, (-imgTop) / s);
      const nw = Math.min(naturalW - nx, vw / s);
      const nh = Math.min(naturalH - ny, vh / s);
      // draw to canvas as square (use vw x vh area)
      const outSize = 200;
      const canvas = document.createElement('canvas');
      canvas.width = outSize; canvas.height = outSize;
      const ctx = canvas.getContext('2d');
      // maintain aspect by drawing the vw/vh region scaled to outSize
      ctx.drawImage(cropImg, nx, ny, nw, nh, 0, 0, outSize, outSize);
      const dataUrl = canvas.toDataURL('image/png');
      const avatar = document.getElementById('profileAvatarImg');
      if (avatar) avatar.src = dataUrl;
      try {
        // store per-user profile pic if logged in; do NOT write the legacy
        // `profile_pic` key for anonymous users (that caused shared avatars).
        const authNow = JSON.parse(sessionStorage.getItem('auth_user') || '{}');
        const usernameNow = authNow && authNow.username ? authNow.username : null;
        if (usernameNow) {
          const key = profileStorageKey(usernameNow);
          localStorage.setItem(key, dataUrl);
        }
      } catch(e){}
    } catch (err) { console.error('Crop failed', err); }
    cropModal.classList.remove('open'); cropModal.setAttribute('aria-hidden','true');
  };
}

// show a brief welcome toast that slides up then down (1s total)
function showWelcomeToast(username) {
  if (!username) return;
  const existing = document.querySelector('.welcome-toast');
  if (existing) existing.remove();
  const el = document.createElement('div');
  el.className = 'welcome-toast';
  el.textContent = `Welcome back, ${username}`;
  document.body.appendChild(el);
  // force reflow then animate
  void el.offsetWidth;
  el.classList.add('animate');
  el.addEventListener('animationend', () => { el.remove(); });
}

/* ========== Landing auth logic (login/register) ========== */
// helper: SHA-256 hash a string and return base64
async function hashPassword(password) {
  const enc = new TextEncoder();
  const data = enc.encode(password);
  const hash = await crypto.subtle.digest('SHA-256', data);
  // convert to base64
  const arr = Array.from(new Uint8Array(hash));
  const bin = arr.map(b => String.fromCharCode(b)).join('');
  return btoa(bin);
}

// demo user store helpers (replace these with backend calls)
function getDemoUsers() {
  try { return JSON.parse(localStorage.getItem('demo_users') || '[]'); } catch (e) { return []; }
}
function saveDemoUsers(list) { try { localStorage.setItem('demo_users', JSON.stringify(list)); } catch(e){} }

// profile storage key helper (per-user)
function profileStorageKey(username) {
  if (!username) return 'profile_pic';
  return 'profile_pic_' + username.toString().toLowerCase();
}

async function registerLanding(username, password, avatarData = null) {
  // placeholder for backend POST /register
  const users = getDemoUsers();
  if (!username || !password) throw new Error('username and password required');
  const exists = users.find(u => u.username.toLowerCase() === username.toLowerCase());
  if (exists) throw new Error('username_taken');
  const pwHash = await hashPassword(password);
  const userObj = { username, pwHash, created: new Date().toISOString() };
  if (avatarData) {
    try {
      userObj.avatarData = avatarData;
      // store per-user key for backwards compatibility
      localStorage.setItem(profileStorageKey(username), avatarData);
    } catch (e) { /* ignore storage errors */ }
  }
  users.push(userObj);
  saveDemoUsers(users);
  // set auth_user for now (session-only so user is logged-out on close)
  const token = 'local_' + Date.now();
  const auth = { username, token };
  try { sessionStorage.setItem('auth_user', JSON.stringify(auth)); } catch(e){}
  return auth;
}

async function loginLanding(username, password) {
  // placeholder for backend POST /login
  const users = getDemoUsers();
  const found = users.find(u => u.username.toLowerCase() === (username||'').toLowerCase());
  if (!found) throw new Error('wrong_credentials');
  const pwHash = await hashPassword(password);
  if (pwHash !== found.pwHash) throw new Error('wrong_credentials');
  const token = 'local_' + Date.now();
  const auth = { username: found.username, token };
  try { sessionStorage.setItem('auth_user', JSON.stringify(auth)); } catch(e){}
  return auth;
}

// wire landing UI
document.addEventListener('DOMContentLoaded', () => {
  const authScreen = document.getElementById('authScreen');
  const tabLogin = document.getElementById('tabLogin');
  const tabRegister = document.getElementById('tabRegister');
  const loginBox = document.getElementById('loginBox');
  const registerBox = document.getElementById('registerBox');

  function showLogin() { tabLogin.classList.add('active'); tabRegister.classList.remove('active'); loginBox.classList.remove('hidden'); registerBox.classList.add('hidden'); }
  function showRegister() { tabLogin.classList.remove('active'); tabRegister.classList.add('active'); loginBox.classList.add('hidden'); registerBox.classList.remove('hidden'); }

  tabLogin.addEventListener('click', showLogin);
  tabRegister.addEventListener('click', showRegister);

  // login handler
  document.getElementById('landingLoginBtn').addEventListener('click', async () => {
    const u = document.getElementById('landingLoginUser').value.trim();
    const p = document.getElementById('landingLoginPass').value;
    document.getElementById('landingLoginMsg').textContent = '';
    try {
      await loginLanding(u, p);
      // load avatar from demo users if present and set into per-user storage & UI
      try {
        const users = getDemoUsers();
        const found = users.find(x => x.username && x.username.toLowerCase() === (u || '').toLowerCase());
        const avatarImg = document.getElementById('profileAvatarImg');
        if (found && found.avatarData) {
          try { localStorage.setItem(profileStorageKey(found.username), found.avatarData); } catch(e){}
          if (avatarImg) avatarImg.src = found.avatarData;
        } else {
          // ensure we do not accidentally show a global legacy avatar for this user
          try { localStorage.removeItem(profileStorageKey(u)); } catch(e){}
          if (avatarImg) avatarImg.src = window.__DEFAULT_PROFILE_AVATAR || avatarImg.src;
        }
      } catch(e) { console.warn('Could not load avatar after login', e); }
      // hide auth screen and update UI
      if (authScreen) authScreen.classList.add('hidden');
      // update profile and header
      try { const stored = JSON.parse(sessionStorage.getItem('auth_user') || '{}'); if (stored && stored.username) { const userInfo = document.getElementById('userInfo'); if (userInfo) { userInfo.textContent = 'Welcome, ' + stored.username; userInfo.classList.remove('hidden'); } const loginHeaderBtn = document.getElementById('loginHeaderBtn'); if (loginHeaderBtn) loginHeaderBtn.classList.add('hidden'); const logoutBtn = document.getElementById('logoutBtn'); if (logoutBtn) logoutBtn.classList.remove('hidden'); if (window.showWelcomeToast) window.showWelcomeToast(stored.username); }} catch(e){}
    } catch (err) {
      console.error('login error', err);
      document.getElementById('landingLoginMsg').textContent = err.message === 'wrong_credentials' ? 'wrong credentials' : (err.message || 'Login failed');
    }
  });

  // register handler
  document.getElementById('landingRegBtn').addEventListener('click', async () => {
    const u = document.getElementById('landingRegUser').value.trim();
    const p = document.getElementById('landingRegPass').value;
    const p2 = document.getElementById('landingRegPass2').value;
    document.getElementById('landingRegMsg').textContent = '';
    if (!u) { document.getElementById('landingRegUserErr').textContent = 'Enter a username'; return; } else { document.getElementById('landingRegUserErr').textContent = ''; }
    if (!p || p.length < 6) { document.getElementById('landingRegPassErr').textContent = 'Password must be 6+ chars'; return; } else { document.getElementById('landingRegPassErr').textContent = ''; }
    if (p !== p2) { document.getElementById('landingRegPass2Err').textContent = 'Passwords do not match'; return; } else { document.getElementById('landingRegPass2Err').textContent = ''; }
    try {
      // check for optional profile picture and read as dataURL if present
      let avatarData = null;
      try {
        const picInput = document.getElementById('landingRegPic');
        if (picInput && picInput.files && picInput.files[0]) {
          const file = picInput.files[0];
          avatarData = await new Promise((resolve, reject) => {
            const r = new FileReader();
            r.onload = () => resolve(r.result);
            r.onerror = () => reject(r.error);
            r.readAsDataURL(file);
          });
        }
      } catch (e) { console.warn('Could not read provided profile picture', e); }

      await registerLanding(u, p, avatarData);
      // hide auth screen and update UI
      if (authScreen) authScreen.classList.add('hidden');
      // update profile name display instantly
      try { const stored = JSON.parse(sessionStorage.getItem('auth_user') || '{}'); if (stored && stored.username) { const userInfo = document.getElementById('userInfo'); if (userInfo) { userInfo.textContent = 'Welcome, ' + stored.username; userInfo.classList.remove('hidden'); } const loginHeaderBtn = document.getElementById('loginHeaderBtn'); if (loginHeaderBtn) loginHeaderBtn.classList.add('hidden'); const logoutBtn = document.getElementById('logoutBtn'); if (logoutBtn) logoutBtn.classList.remove('hidden'); if (window.showWelcomeToast) window.showWelcomeToast(stored.username); }} catch(e){}
      // after registering, ensure avatar is visible in UI
      try {
        const key = profileStorageKey(u);
        const pic = localStorage.getItem(key);
        if (pic) {
          const avatarImg = document.getElementById('profileAvatarImg');
          if (avatarImg) avatarImg.src = pic;
        }
      } catch (e) { /* ignore */ }
    } catch (err) {
      console.error('register error', err);
      document.getElementById('landingRegMsg').textContent = err.message === 'username_taken' ? 'username taken' : (err.message || 'Registration failed');
    }
  });

  // show auth screen on load if no auth_user
  const current = sessionStorage.getItem('auth_user');
  if (!current) {
    if (authScreen) authScreen.classList.remove('hidden');
    showLogin();
  } else {
    if (authScreen) authScreen.classList.add('hidden');
  }
});
</script>

</body>
</html>
